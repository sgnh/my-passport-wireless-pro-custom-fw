//#include <stdio.h>
//#include <stdlib.h>
//#include <string.h>
#include <linux/string.h>
//#include <sysdefs.h>
//#include "sysdefs.h"
#include "I2CUtil.h"
//#include <Platform_Lib/Board/pcbMgr.h>
#include <platform_lib/board/pcb_mgr.h>
#include <common.h>
#include <command.h>
#include <malloc.h>
#include <linux/compiler.h>
#include <asm/io.h>
#include "AudioAmp.h"
//#define udelay(x)			usleep(x)

static unsigned long long m_I2C_MASTER=0, m_AMP_DEVICE_ADDR=0, m_PIN_AMP_MUTE=0;
static unsigned long long m_PIN_951_RST=0;
#if 0
#if defined(BOARD_ID_RTD2974_HISENSE_V1)|| defined(BOARD_ID_RTD2974_HISENSE_V2)
static unsigned long long m_PIN_HEADPHONE_PLUG_IN=0;
#endif
#endif

#define ENABLE_AMP_USE_HW_I2C
#define CONFIG_AT_TV010_K05_BOARD_296C 1


#define ErrCode int
//#define FALSE		(0)
//#define TRUE		(1)
#define R_ERR_RX_ERROR		(0)
#define R_ERR_SUCCESS		(1)

typedef struct
{
	UINT8   UINT8Adr;
	UINT8   UINT8DataLen;
	UINT8    *pUINT8Datas;
} sInitTSA5711Reg;

//tlm 20110108
#if 0
UINT8   UINT8Reg10Value[]={0x02};  //Modulation limit register
UINT8   UINT8Reg0BValue[]={0x00};  //Reserved
UINT8   UINT8Reg1CValue[]={0x02};  //BKND_ERR register

UINT8   UINT8Reg59Value[]={0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
UINT8   UINT8Reg5DValue[]={0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
UINT8   UINT8Reg5EValue[]={0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
UINT8   UINT8Reg5FValue[]={0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
UINT8   UINT8Reg60Value[]={0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00};                                    //Ch4 (subchannel) output mixer
UINT8   UINT8Reg56Value[]={0x00,0x80,0x00,0x00};    //Output post-scale
UINT8   UINT8Reg57Value[]={0x00,0x02,0x00,0x00};    //Output pre-scale
UINT8   UINT8Reg53Value[]={0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00}; //CH1 input mixer
UINT8   UINT8Reg55Value[]={0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                                 //CH3 input mixer
UINT8   UINT8Reg54Value[]={0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00}; //CH2 input mixer
UINT8   UINT8Reg51Value[]={0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};   //CH1 output mixer
#endif

//UINT8   UINT8Reg50Value[]={0x00,0x00,0x00,0x00};

//mixer & scale
UINT8   UINT8Reg06Value[]={0x00};  //Soft mute register
UINT8   UINT8Reg0AValue[]={0x3A};  //重低音音量

UINT8   UINT8Reg05Value[]={0x84};   //System Ctl Register2
//UINT8   UINT8Reg08Value[]={0x00};  //CH1 Volume
//UINT8   UINT8Reg09Value[]={0x00};  //CH2 Volume

#ifdef Board_AMP_POWER_8OHM
UINT8   UINT8Reg08Value[]={0x1a};  //CH1 Volume  //tlm 20111111 32e83
UINT8   UINT8Reg09Value[]={0x1a};  //CH2 Volume  //tlm 20111111 32e83
#else  //6ohm
UINT8   UINT8Reg08Value[]={0x10};  //CH1 Volume
UINT8   UINT8Reg09Value[]={0x10};  //CH2 Volume
#endif

UINT8   UINT8Reg0EValue[]={0xD1};  //Volume configuration register
#if defined(CONFIG_AT_TV010_E60_BOARD_296C)||defined(CONFIG_AT_TV010_E20_BOARD_296C) ||defined(CONFIG_AT_TV010_E62_BOARD_296C)
UINT8   UINT8Reg19Value[]={0x3c};  //PWM SHUTDOWN GROUP REGISTER
#else
UINT8   UINT8Reg19Value[]={0x30};  //PWM SHUTDOWN GROUP REGISTER
#endif
UINT8   UINT8Reg1BValue[]={0x00};  //Oscillator trim register

#ifdef Board_AMP_POWER_8OHM
UINT8   UINT8Reg07Value[]={0x30};   //Master Volume  //tlm 20111111 32e83
#else  //6ohm
UINT8   UINT8Reg07Value[]={0x3a};   //Master Volume  //tlm add 20100919
#endif

UINT8   UINT8Reg14Value[]={0x00};  //IC delay channel 4
UINT8   UINT8Reg13Value[]={0x00};  //IC delay channel 3
UINT8   UINT8Reg12Value[]={0x54};  //IC delay channel 2
UINT8   UINT8Reg11Value[]={0xAC};  //IC delay channel 1
UINT8   UINT8Reg03Value[]={0x80};   //System Control Register 1
UINT8   UINT8Reg1AValue[]={0x95};  //Start/stop period register
UINT8   UINT8Reg20Value[]={0x00,0x01,0x77,0x72};  //Input MUX register
//UINT8   UINT8Reg20Value[]={0x00,0x10,0x77,0x72};  //Input MUX register
UINT8   UINT8Reg21Value[]={0x00,0x00,0x42,0x03};  //Ch 4 source select register
//UINT8   UINT8Reg21Value[]={0x00,0x00,0x43,0x03};  //Ch 4 source select register, for super bass 2.1 ch use


//UINT8   UINT8Reg25Value[]={0x01,0x01,0x32,0x45}; //PWM MUX register
UINT8   UINT8Reg25Value[]={0x01,0x10,0x32,0x45}; //PWM MUX register, replaced Left with Right, replaced Right with Left
UINT8   UINT8Reg50Value[]={0x00,0x00,0x00,0x02};
UINT8   UINT8Reg52Value[]={0x0f,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};    //CH2 output mixer

//EQ
#ifdef Board_AMP_POWER_8OHM    //tlm 20111117 32e83(=32e650s)
/*
UINT8   UINT8Reg29Value[]={0x00,0x7D,0xFE,0x49,0xFF,0x2B,0xE6,0xD8,0x00,0x6E,0x7E,0x40,0x00,0xD4,0x19,0x28,0xFF,0x93,0x83,0x77};
UINT8   UINT8Reg2AValue[]={0x00,0x81,0x40,0xC0,0xFF,0x0A,0x34,0x96,0x00,0x75,0x11,0xAC,0x00,0xF5,0xCB,0x6A,0xFF,0x89,0xAD,0x93};
UINT8   UINT8Reg2BValue[]={0x00,0x7D,0xFE,0x49,0xFF,0x3B,0x5E,0x62,0x00,0x6E,0x7E,0x40,0x00,0xC4,0xA1,0x9E,0xFF,0x93,0x83,0x77};
UINT8   UINT8Reg2CValue[]={0x00,0x7D,0x6B,0x7C,0xFF,0x05,0x29,0x08,0x00,0x7D,0x6B,0x7C,0x00,0xFA,0xC9,0xA7,0xFF,0x85,0x1B,0xB7};
UINT8   UINT8Reg2DValue[]={0x00,0x7D,0x6B,0x7C,0xFF,0x05,0x29,0x08,0x00,0x7D,0x6B,0x7C,0x00,0xFA,0xC9,0xA7,0xFF,0x85,0x1B,0xB7};
UINT8   UINT8Reg2EValue[]={0x00,0x86,0x24,0xA3,0xFF,0x76,0x49,0x8D,0x00,0x5C,0x13,0x21,0x00,0x89,0xB6,0x73,0xFF,0x9D,0xC8,0x3B};
UINT8   UINT8Reg2FValue[]={0x00,0x88,0xC2,0xC9,0xFF,0xC8,0xBC,0x35,0x00,0x4C,0xC4,0x17,0x00,0x37,0x43,0xCB,0xFF,0xAA,0x79,0x20};
UINT8   UINT8Reg30Value[]={0x00,0x7D,0xFE,0x49,0xFF,0x2B,0xE6,0xD8,0x00,0x6E,0x7E,0x40,0x00,0xD4,0x19,0x28,0xFF,0x93,0x83,0x77};
UINT8   UINT8Reg31Value[]={0x00,0x81,0x40,0xC0,0xFF,0x0A,0x34,0x96,0x00,0x75,0x11,0xAC,0x00,0xF5,0xCB,0x6A,0xFF,0x89,0xAD,0x93};
UINT8   UINT8Reg32Value[]={0x00,0x7D,0xFE,0x49,0xFF,0x3B,0x5E,0x62,0x00,0x6E,0x7E,0x40,0x00,0xC4,0xA1,0x9E,0xFF,0x93,0x83,0x77};
UINT8   UINT8Reg33Value[]={0x00,0x7D,0x6B,0x7C,0xFF,0x05,0x29,0x08,0x00,0x7D,0x6B,0x7C,0x00,0xFA,0xC9,0xA7,0xFF,0x85,0x1B,0xB7};
UINT8   UINT8Reg34Value[]={0x00,0x7D,0x6B,0x7C,0xFF,0x05,0x29,0x08,0x00,0x7D,0x6B,0x7C,0x00,0xFA,0xC9,0xA7,0xFF,0x85,0x1B,0xB7};
UINT8   UINT8Reg35Value[]={0x00,0x86,0x24,0xA3,0xFF,0x76,0x49,0x8D,0x00,0x5C,0x13,0x21,0x00,0x89,0xB6,0x73,0xFF,0x9D,0xC8,0x3B};
UINT8   UINT8Reg36Value[]={0x00,0x88,0xC2,0xC9,0xFF,0xC8,0xBC,0x35,0x00,0x4C,0xC4,0x17,0x00,0x37,0x43,0xCB,0xFF,0xAA,0x79,0x20};
*/
UINT8   UINT8Reg29Value[]={0x00,0x7D,0xFE,0x49,0xFF,0x2B,0xE6,0xD8,0x00,0x6E,0x7E,0x40,0x00,0xD4,0x19,0x28,0xFF,0x93,0x83,0x77};
UINT8   UINT8Reg2AValue[]={0x00,0x81,0x40,0xC0,0xFF,0x0A,0x34,0x96,0x00,0x75,0x11,0xAC,0x00,0xF5,0xCB,0x6A,0xFF,0x89,0xAD,0x93};
UINT8   UINT8Reg2BValue[]={0x00,0x7D,0xFE,0x49,0xFF,0x3B,0x5E,0x62,0x00,0x6E,0x7E,0x40,0x00,0xC4,0xA1,0x9E,0xFF,0x93,0x83,0x77};
UINT8   UINT8Reg2CValue[]={0x00,0x7D,0x6B,0x7C,0xFF,0x05,0x29,0x08,0x00,0x7D,0x6B,0x7C,0x00,0xFA,0xC9,0xA7,0xFF,0x85,0x1B,0xB7};
UINT8   UINT8Reg2DValue[]={0x00,0x7D,0x6B,0x7C,0xFF,0x05,0x29,0x08,0x00,0x7D,0x6B,0x7C,0x00,0xFA,0xC9,0xA7,0xFF,0x85,0x1B,0xB7};
UINT8   UINT8Reg2EValue[]={0x00,0x84,0xF7,0x6C,0xFF,0x60,0x0A,0x32,0x00,0x5D,0x40,0x59,0x00,0x9F,0xF5,0xCE,0xFF,0x9D,0xC8,0x3B};
UINT8   UINT8Reg2FValue[]={0x00,0x8B,0x28,0xB2,0xFF,0xB2,0xBC,0x64,0x00,0x3E,0xBD,0xEA,0x00,0x4D,0x43,0x9C,0xFF,0xB6,0x19,0x63};
UINT8   UINT8Reg30Value[]={0x00,0x7D,0xFE,0x49,0xFF,0x2B,0xE6,0xD8,0x00,0x6E,0x7E,0x40,0x00,0xD4,0x19,0x28,0xFF,0x93,0x83,0x77};
UINT8   UINT8Reg31Value[]={0x00,0x81,0x40,0xC0,0xFF,0x0A,0x34,0x96,0x00,0x75,0x11,0xAC,0x00,0xF5,0xCB,0x6A,0xFF,0x89,0xAD,0x93};
UINT8   UINT8Reg32Value[]={0x00,0x7D,0xFE,0x49,0xFF,0x3B,0x5E,0x62,0x00,0x6E,0x7E,0x40,0x00,0xC4,0xA1,0x9E,0xFF,0x93,0x83,0x77};
UINT8   UINT8Reg33Value[]={0x00,0x7D,0x6B,0x7C,0xFF,0x05,0x29,0x08,0x00,0x7D,0x6B,0x7C,0x00,0xFA,0xC9,0xA7,0xFF,0x85,0x1B,0xB7};
UINT8   UINT8Reg34Value[]={0x00,0x7D,0x6B,0x7C,0xFF,0x05,0x29,0x08,0x00,0x7D,0x6B,0x7C,0x00,0xFA,0xC9,0xA7,0xFF,0x85,0x1B,0xB7};
UINT8   UINT8Reg35Value[]={0x00,0x84,0xF7,0x6C,0xFF,0x60,0x0A,0x32,0x00,0x5D,0x40,0x59,0x00,0x9F,0xF5,0xCE,0xFF,0x9D,0xC8,0x3B};
UINT8   UINT8Reg36Value[]={0x00,0x8B,0x28,0xB2,0xFF,0xB2,0xBC,0x64,0x00,0x3E,0xBD,0xEA,0x00,0x4D,0x43,0x9C,0xFF,0xB6,0x19,0x63};
#else //424755E650S
UINT8   UINT8Reg29Value[]={0x00,0x80,0x6D,0xA1,0xFF,0x04,0x16,0x3F,0x00,0x7C,0x43,0x8A,0x00,0xFB,0xE9,0xC1,0xFF,0x83,0x4E,0xD4};
UINT8   UINT8Reg2AValue[]={0x00,0x80,0x66,0x07,0xFF,0x0B,0x53,0x74,0x00,0x79,0x11,0xA4,0x00,0xF4,0xAC,0x8C,0xFF,0x86,0x88,0x55};
UINT8   UINT8Reg2BValue[]={0x00,0x7E,0x3C,0x31,0xFF,0x03,0x87,0x9E,0x00,0x7E,0x3C,0x31,0x00,0xFC,0x72,0x27,0xFF,0x83,0x81,0x63};
UINT8   UINT8Reg2CValue[]={0x00,0x85,0x7F,0xA9,0xFF,0x7E,0x03,0x5A,0x00,0x50,0x07,0x36,0x00,0x81,0xFC,0xA6,0xFF,0xAA,0x79,0x20};
UINT8   UINT8Reg2DValue[]={0x00,0x83,0xDB,0x0D,0xFF,0xE2,0x79,0x00,0x00,0x5E,0x5C,0xB7,0x00,0x1D,0x87,0x00,0xFF,0x9D,0xC8,0x3B};
UINT8   UINT8Reg2EValue[]={0x00,0x85,0x7F,0xA9,0x00,0x37,0x43,0xCB,0x00,0x50,0x07,0x36,0xFF,0xC8,0xBC,0x35,0xFF,0xAA,0x79,0x20};
//UINT8   UINT8Reg2FValue[]={0x00,0x85,0x7F,0xA9,0x00,0x37,0x43,0xCB,0x00,0x50,0x07,0x36,0xFF,0xC8,0xBC,0x35,0xFF,0xAA,0x79,0x20};
UINT8   UINT8Reg30Value[]={0x00,0x80,0x6D,0xA1,0xFF,0x04,0x16,0x3F,0x00,0x7C,0x43,0x8A,0x00,0xFB,0xE9,0xC1,0xFF,0x83,0x4E,0xD4};
UINT8   UINT8Reg31Value[]={0x00,0x80,0x66,0x07,0xFF,0x0B,0x53,0x74,0x00,0x79,0x11,0xA4,0x00,0xF4,0xAC,0x8C,0xFF,0x86,0x88,0x55};
UINT8   UINT8Reg32Value[]={0x00,0x7E,0x3C,0x31,0xFF,0x03,0x87,0x9E,0x00,0x7E,0x3C,0x31,0x00,0xFC,0x72,0x27,0xFF,0x83,0x81,0x63};
UINT8   UINT8Reg33Value[]={0x00,0x85,0x7F,0xA9,0xFF,0x7E,0x03,0x5A,0x00,0x50,0x07,0x36,0x00,0x81,0xFC,0xA6,0xFF,0xAA,0x79,0x20};
UINT8   UINT8Reg34Value[]={0x00,0x83,0xDB,0x0D,0xFF,0xE2,0x79,0x00,0x00,0x5E,0x5C,0xB7,0x00,0x1D,0x87,0x00,0xFF,0x9D,0xC8,0x3B};
UINT8   UINT8Reg35Value[]={0x00,0x85,0x7F,0xA9,0x00,0x37,0x43,0xCB,0x00,0x50,0x07,0x36,0xFF,0xC8,0xBC,0x35,0xFF,0xAA,0x79,0x20};
//UINT8   UINT8Reg36Value[]={0x00,0x85,0x7F,0xA9,0x00,0x37,0x43,0xCB,0x00,0x50,0x07,0x36,0xFF,0xC8,0xBC,0x35,0xFF,0xAA,0x79,0x20};
#endif

//重低音截止频率
//UINT8   UINT8Reg5AValue[]={0x00,0x00,0x0C,0x4A,0x00,0x00,0x18,0x94,0x00,0x00,0x0C,0x4A,0x00,0xF8,0xE4,0xA4,0xFF,0x86,0xEA,0x32};
//UINT8   UINT8Reg5BValue[]={0x00,0x00,0x0C,0x4A,0x00,0x00,0x18,0x94,0x00,0x00,0x0C,0x4A,0x00,0xF8,0xE4,0xA4,0xFF,0x86,0xEA,0x32};
UINT8   UINT8Reg5AValue[]={0x00,0x00,0x05,0x83,0x00,0x00,0x0B,0x06,0x00,0x00,0x05,0x83,0x00,0xFB,0x42,0xC1,0x0F,0x84,0xA7,0x33};
UINT8   UINT8Reg5BValue[]={0x00,0x00,0x05,0x83,0x00,0x00,0x0B,0x06,0x00,0x00,0x05,0x83,0x00,0xFB,0x42,0xC1,0x0F,0x84,0xA7,0x33};

//!DRCs
UINT8   UINT8Reg3AValue[]={0x00,0x05,0x39,0x47,0x00,0x7A,0xC6,0xB8};   //DRC1 ae
UINT8   UINT8Reg3BValue[]={0x00,0x05,0x39,0x47,0x00,0x7A,0xC6,0xB8};   //DRC1 aa
UINT8   UINT8Reg3CValue[]={0x00,0x00,0x00,0xF9,0x00,0x7F,0xFF,0x06};   //DRC1 ad
UINT8   UINT8Reg3DValue[]={0x00,0x05,0x39,0x47,0x00,0x7A,0xC6,0xB8};   //DRC2 ae
UINT8   UINT8Reg3EValue[]={0x00,0x05,0x39,0x47,0x00,0x7A,0xC6,0xB8};   //DRC2 aa
UINT8   UINT8Reg3FValue[]={0x00,0x00,0x00,0xF9,0x00,0x7F,0xFF,0x06};   //DRC2 ad

UINT8   UINT8Reg40Value[]={0xfd,0xD7,0x3B,0x2E};     //tlm 20110707                               //主通道限幅
//UINT8   UINT8Reg41Value[]={0x0F,0x81,0x47,0xAF};                                  //DRC1-K
UINT8   UINT8Reg41Value[]={0x0F,0x70,0x80,0x00};
UINT8   UINT8Reg42Value[]={0x00,0x08,0x42,0x10};                                   //DRC1-O
UINT8   UINT8Reg43Value[]={0xFD,0x97,0x73,0x3D};                                   //重低音限幅
UINT8   UINT8Reg44Value[]={0x0F,0x81,0x47,0xAF};                                   //DRC2-K
UINT8   UINT8Reg45Value[]={0x00,0x08,0x42,0x10};                                   //DRC2-O
UINT8   UINT8Reg46Value[]={0x00,0x00,0x00,0x03};                                   //DRC Control 开关


sInitTSA5711Reg   asInitTSA5711SReg[] = {
	//Adr         DataLen       pData
// step1. Trim oscillator (write 0x00 to register 0x1B) and wait at least 50ms.
	{0x1B,sizeof(UINT8Reg1BValue),UINT8Reg1BValue},  //must
	{0x1B,sizeof(UINT8Reg1BValue),UINT8Reg1BValue},
	{0x1B,sizeof(UINT8Reg1BValue),UINT8Reg1BValue},
	{0x1B,sizeof(UINT8Reg1BValue),UINT8Reg1BValue},
	{0x1B,sizeof(UINT8Reg1BValue),UINT8Reg1BValue},

#if 0 //only set must, to avoid that bootcode no set audioAmp
//	{0x07,sizeof(UINT8Reg07Value),UINT8Reg07Value},  //must all vol unmute and all_vol + 0db
//	{0x05,sizeof(UINT8Reg05Value),UINT8Reg05Value},  //must
//	{0x08,sizeof(UINT8Reg08Value),UINT8Reg08Value},  //must vol_L + 16db
//	{0x09,sizeof(UINT8Reg09Value),UINT8Reg09Value},  //must vol_R + 16db
	{0x06,sizeof(UINT8Reg06Value),UINT8Reg06Value},
	//{0x05,sizeof(UINT8Reg05Value),UINT8Reg05Value}, //move to final
	{0x08,sizeof(UINT8Reg08Value),UINT8Reg08Value},
	{0x09,sizeof(UINT8Reg09Value),UINT8Reg09Value},
	{0x0E,sizeof(UINT8Reg0EValue),UINT8Reg0EValue},
	{0x19,sizeof(UINT8Reg19Value),UINT8Reg19Value},
	{0x07,sizeof(UINT8Reg07Value),UINT8Reg07Value},

	{0x20,sizeof(UINT8Reg20Value),UINT8Reg20Value},
	{0x21,sizeof(UINT8Reg21Value),UINT8Reg21Value},
	{0x25,sizeof(UINT8Reg25Value),UINT8Reg25Value},

	{0x52,sizeof(UINT8Reg52Value),UINT8Reg52Value},  //输出相位反
	{0x05,sizeof(UINT8Reg05Value),UINT8Reg05Value}, //Exit Shutdown Mode, must final
#else
	{0x06,sizeof(UINT8Reg06Value),UINT8Reg06Value},
	//{0x05,sizeof(UINT8Reg05Value),UINT8Reg05Value}, //move to final
	{0x08,sizeof(UINT8Reg08Value),UINT8Reg08Value},
	{0x09,sizeof(UINT8Reg09Value),UINT8Reg09Value},
	{0x0E,sizeof(UINT8Reg0EValue),UINT8Reg0EValue},
	{0x19,sizeof(UINT8Reg19Value),UINT8Reg19Value},
	{0x07,sizeof(UINT8Reg07Value),UINT8Reg07Value},
	{0x14,sizeof(UINT8Reg14Value),UINT8Reg14Value},
	{0x13,sizeof(UINT8Reg13Value),UINT8Reg13Value},
	{0x12,sizeof(UINT8Reg12Value),UINT8Reg12Value},
	{0x11,sizeof(UINT8Reg11Value),UINT8Reg11Value},
	{0x03,sizeof(UINT8Reg03Value),UINT8Reg03Value},
	{0x1A,sizeof(UINT8Reg1AValue),UINT8Reg1AValue},
	{0x20,sizeof(UINT8Reg20Value),UINT8Reg20Value},
	{0x21,sizeof(UINT8Reg21Value),UINT8Reg21Value},
	{0x25,sizeof(UINT8Reg25Value),UINT8Reg25Value},

	{0x52,sizeof(UINT8Reg52Value),UINT8Reg52Value},  //输出相位反

	//EQ  //if compile 32, open it star_liu20111130
	{0x29,sizeof(UINT8Reg29Value),UINT8Reg29Value},
	{0x2A,sizeof(UINT8Reg2AValue),UINT8Reg2AValue},
	{0x2B,sizeof(UINT8Reg2BValue),UINT8Reg2BValue},
	{0x2C,sizeof(UINT8Reg2CValue),UINT8Reg2CValue},
	{0x2D,sizeof(UINT8Reg2DValue),UINT8Reg2DValue},
	{0x2E,sizeof(UINT8Reg2EValue),UINT8Reg2EValue},
	#ifdef Board_AMP_POWER_8OHM	    //tlm 20111130
	{0x2F,sizeof(UINT8Reg2FValue),UINT8Reg2FValue},
	#endif
	{0x30,sizeof(UINT8Reg30Value),UINT8Reg30Value},
	{0x31,sizeof(UINT8Reg31Value),UINT8Reg31Value},
	{0x32,sizeof(UINT8Reg32Value),UINT8Reg32Value},
	{0x33,sizeof(UINT8Reg33Value),UINT8Reg33Value},
	{0x34,sizeof(UINT8Reg34Value),UINT8Reg34Value},
	{0x35,sizeof(UINT8Reg35Value),UINT8Reg35Value},
	#ifdef Board_AMP_POWER_8OHM	    //tlm 20111130
	{0x36,sizeof(UINT8Reg36Value),UINT8Reg36Value},
	#endif

	{0x5A,sizeof(UINT8Reg5AValue),UINT8Reg5AValue},   //重低音截止频率，200hz
	{0x5B,sizeof(UINT8Reg5BValue),UINT8Reg5BValue},  //重低音截止频率，200hz
	{0x50,sizeof(UINT8Reg50Value),UINT8Reg50Value},


	//DRC

	{0x40,sizeof(UINT8Reg40Value),UINT8Reg40Value},   //主通道音量限幅
	{0x41,sizeof(UINT8Reg41Value),UINT8Reg41Value},   //斜率
	{0x42,sizeof(UINT8Reg42Value),UINT8Reg42Value},   //斜率
	{0x43,sizeof(UINT8Reg43Value),UINT8Reg43Value},   //重低音限幅
	{0x44,sizeof(UINT8Reg44Value),UINT8Reg44Value},   //斜率
	{0x45,sizeof(UINT8Reg45Value),UINT8Reg45Value},   //斜率
	{0x46,sizeof(UINT8Reg46Value),UINT8Reg46Value},    //DRC开关
	//左右通道
	{0x3A,sizeof(UINT8Reg3AValue),UINT8Reg3AValue},     //检测时间
	{0x3B,sizeof(UINT8Reg3BValue),UINT8Reg3BValue},    //检测时间
	{0x3C,sizeof(UINT8Reg3CValue),UINT8Reg3CValue},    //恢复时间
	//重低音通道
	{0x3D,sizeof(UINT8Reg3DValue),UINT8Reg3DValue},   //检测时间
	{0x3E,sizeof(UINT8Reg3EValue),UINT8Reg3EValue},   //检测时间
	{0x3F,sizeof(UINT8Reg3FValue),UINT8Reg3FValue},    //恢复时间

	{0x05,sizeof(UINT8Reg05Value),UINT8Reg05Value}, //Exit Shutdown Mode, must final
#endif
};


UINT8   UINT8_5707_Reg07Value[]={0x40};   //Master Volume    //RTK

// I am 5707, I am 5707, I am 5707, I am 5707, I am 5707, I am 5707, I am 5707, I am 5707,
// I am 5707, I am 5707, I am 5707, I am 5707, I am 5707, I am 5707, I am 5707, I am 5707,
sInitTSA5711Reg   asInitTSA5707SReg[] = {
	//Adr         DataLen       pData

// step1. Trim oscillator (write 0x00 to register 0x1B) and wait at least 50ms.
	{0x1B,sizeof(UINT8Reg1BValue),UINT8Reg1BValue},  //must

#if 1 //only set must
	{0x07,sizeof(UINT8_5707_Reg07Value), UINT8_5707_Reg07Value},  //must all vol unmute and all_vol + 0db
	{0x08,sizeof(UINT8Reg08Value),UINT8Reg08Value},  //must vol_L + 16db
	{0x09,sizeof(UINT8Reg09Value),UINT8Reg09Value},  //must vol_R + 16db
	{0x05,sizeof(UINT8Reg05Value),UINT8Reg05Value}, //Exit Shutdown Mode, must final
#endif
};
//lzf100728  end
//#endif

//*************************************************************
// PRIVATE FUNCTIONS
//*************************************************************
static ErrCode AudioAmp_AdoAmp_Tas5711L_write(UINT8 i2c_master,UINT8 w_len, UINT8* write_buf)
{
	if (!m_AMP_DEVICE_ADDR)
		return R_ERR_RX_ERROR;

	if (I2C_Write_EX(i2c_master, m_AMP_DEVICE_ADDR, w_len, write_buf) != S_OK) {
		//printf("%s %s %d\n", __FILE__, __FUNCTION__, __LINE__);
		return R_ERR_RX_ERROR;
	}
	//udelay(10000); //use HW i2c need to add this to avoid set error

	return R_ERR_SUCCESS;
}

void AudioAmp_InitTas5707L(UINT8 devAddr)
{
	UINT8 dat[23], i=0;
	//UINT8 rdat[3];
	//SrAudio_SetAmpMute(FALSE);

	printf("init TAS5707\n");

//bcoz PCB design error, need workaround I2C source switch
//0xb800_08C0[23:20] = 0x8 / 0xb806_02A0[5:4] = 0x3  <-- AMP
//0xb800_08C0[23:20] = 0x0 / 0xb806_02A0[5:4] = 0x3  <-- Tuner
rtd_maskl(0xb80008c0, 0xFF0FFFFF, 0x00800000); //AMP

	while (i < (sizeof(asInitTSA5707SReg)/sizeof(sInitTSA5711Reg)))
	{
		dat[0] =asInitTSA5707SReg[i].UINT8Adr;
		memcpy(&dat[1],asInitTSA5707SReg[i].pUINT8Datas,asInitTSA5707SReg[i].UINT8DataLen);

		if( R_ERR_RX_ERROR == AudioAmp_AdoAmp_Tas5711L_write(m_I2C_MASTER,asInitTSA5707SReg[i].UINT8DataLen+1,&dat[0]))
			printf(" err!UINT8Adr=[0x%x],UINT8DataLen=[%u]\n",asInitTSA5707SReg[i].UINT8Adr,asInitTSA5707SReg[i].UINT8DataLen);

		if(i == 0x00)
		{
			udelay(60000);
		}

		i++;
	}

//bcoz PCB design error, need workaround I2C source switch
//0xb800_08C0[23:20] = 0x8 / 0xb806_02A0[5:4] = 0x3  <-- AMP
//0xb800_08C0[23:20] = 0x0 / 0xb806_02A0[5:4] = 0x3  <-- Tuner
rtd_maskl(0xb80008c0, 0xFF0FFFFF, 0x00000000); //Tuner

	//printf("InitTas5707L ok\n");
}

void AudioAmp_InitTas5711L(UINT8 devAddr)
{
	UINT8 dat[23], i=0;
	//UINT8 rdat[3];
	//SrAudio_SetAmpMute(FALSE);

	printf("init TAS5711\n");
	display_evaluate_time("amp_internal-001");

	while (i < (sizeof(asInitTSA5711SReg)/sizeof(sInitTSA5711Reg)))
	{
		dat[0] =asInitTSA5711SReg[i].UINT8Adr;
		memcpy(&dat[1],asInitTSA5711SReg[i].pUINT8Datas,asInitTSA5711SReg[i].UINT8DataLen);

		if( R_ERR_RX_ERROR == AudioAmp_AdoAmp_Tas5711L_write(m_I2C_MASTER,asInitTSA5711SReg[i].UINT8DataLen+1,&dat[0]))
			printf(" err!UINT8Adr=[0x%x],UINT8DataLen=[%u]\n",asInitTSA5711SReg[i].UINT8Adr,asInitTSA5711SReg[i].UINT8DataLen);
#if 1
		if(i == 0x00)
		{
			display_evaluate_time("amp_internal-0011");
			udelay(60000);
		}
#endif
		display_evaluate_time("amp_internal-002");
		i++;
	}

	AudioAmp_SetSubWoof(0);
	display_evaluate_time("amp_internal-003");
	//printf("InitTas5711L ok\n");
}
//#endif

void AudioAmp_SetOscillator(void)
{
#if defined(ENABLE_AMP_USE_HW_I2C)
	UINT8 dat[2];
	dat[0]= 0x1B;
	dat[1]= 0x00;

	if (m_AMP_DEVICE_ADDR == 0x1a) { //5711
		//do nothing
	}
	else {	//5707
		udelay(300000);
		printf("init TAS5707\n");

		//bcoz PCB design error, need workaround I2C source switch
		//0xb800_08C0[23:20] = 0x8 / 0xb806_02A0[5:4] = 0x3  <-- AMP
		//0xb800_08C0[23:20] = 0x0 / 0xb806_02A0[5:4] = 0x3  <-- Tuner
		rtd_maskl(0xb80008c0, 0xFF0FFFFF, 0x00800000); //AMP
	}

	AudioAmp_AdoAmp_Tas5711L_write(m_I2C_MASTER,2,dat);
#endif
}

void AudioAmp_Set951RST(BOOL val)
{
	if (m_PIN_951_RST) {
		//reset Yamaha YYS951
//		IO_Set(m_PIN_951_RST, 1);
//		udelay(100000);
		IO_Set(m_PIN_951_RST, val);
	}
}

//*************************************************************
// PUBLIC FUNCTIONS
//*************************************************************
void AudioAmp_InitAudioOut2I2S_1st(void)
{

	unsigned long long value=0;
	if (pcb_mgr_get_enum_info_byname("AMP_I2C", &value) < 0) {
		printf("no AMP_I2C\n");
		m_I2C_MASTER = 0;
	} else {
		m_I2C_MASTER = value;
		printf("get AMP_I2C %08x%08x\n", HI32(value), LO32(value));
	}
	if (pcb_mgr_get_enum_info_byname("AMP_DEVICE_ADDR", &value) < 0) {
		printf("no AMP_DEVICE_ADDR\n");
		m_AMP_DEVICE_ADDR = 0;
	} else {
		m_AMP_DEVICE_ADDR = value;
		printf("get AMP_DEVICE_ADDR %08x%08x \n", HI32(value), LO32(value));

	}
	if (pcb_mgr_get_enum_info_byname("PIN_AMP_MUTE", &value) < 0) {
		printf("no PIN_AMP_MUTE\n");
		m_PIN_AMP_MUTE = 0;
	} else {
		m_PIN_AMP_MUTE = value;
		printf("get AMP_MUTE %08x%08x\n", HI32(value), LO32(value));

	}

	if (pcb_mgr_get_enum_info_byname("PIN_MISC_951_RST", &value) < 0) {
		printf("no PIN_MISC_951_RST\n");
		m_PIN_951_RST = 0;
	} else {
		m_PIN_951_RST = value;
		printf("get MISC_951_RST = %08x%08x\n", HI32(value), LO32(value));
	}
#if 0
#if defined(BOARD_ID_RTD2974_HISENSE_V1)|| defined(BOARD_ID_RTD2974_HISENSE_V2)
	if (pcb_mgr_get_enum_info_byname("PIN_HEADPHONE_PLUG_IN", &value) < 0) {
		printf("no PIN_HEADPHONE_PLUG_IN\n");
		m_PIN_HEADPHONE_PLUG_IN = 0;
	} else {
		m_PIN_HEADPHONE_PLUG_IN = value;
		//printf("get HEADPHONE_PLUG_IN = %08x%08x\n", HI32(value), LO32(value));

	}
#endif
#endif
	if (m_PIN_AMP_MUTE) {
		//reset AMP
#if 0
#if defined(BOARD_ID_RTD2974_HISENSE_V1)|| defined(BOARD_ID_RTD2974_HISENSE_V2)
	if (IO_Get(m_PIN_HEADPHONE_PLUG_IN))
		IO_Set(m_PIN_AMP_MUTE, 1);
	else
#endif
#endif
		IO_Set(m_PIN_AMP_MUTE, 0);
		printf("get m_PIN_AMP_MUTE = %d (reset AMP!)\n", m_PIN_AMP_MUTE);

	}
	if (m_PIN_951_RST) {
		//reset Yamaha YYS951
		IO_Set(m_PIN_951_RST, 1);
//		udelay(100000);
//		IO_Set(m_PIN_951_RST, 0);
		printf("get m_PIN_951_RST = %d (reset Yamaha YYS951!)\n", m_PIN_951_RST);
	}

	I2C_Init();
}

void AudioAmp_InitAudioOut2I2S_2nd(void)
{
#ifdef Board_PANEL_SLOWBOOT
	udelay(300000);
#endif
//	I2C_SetSpeed(m_I2C_MASTER, 400);

	if (m_PIN_951_RST) {
		//reset Yamaha YYS951
//		IO_Set(m_PIN_951_RST, 1);
//		udelay(100000);
		IO_Set(m_PIN_951_RST, 0);
	}

	//I2C_SetSpeed(m_I2C_MASTER, 100);

	if (m_AMP_DEVICE_ADDR == 0x1a) //5711
		AudioAmp_InitTas5711L(m_AMP_DEVICE_ADDR);
	else
		AudioAmp_InitTas5707L(m_AMP_DEVICE_ADDR);
}

void AudioAmp_SetMute(BOOL isMute)
{
#if defined(ENABLE_AMP_USE_HW_I2C)
	UINT8 dat[2];
	//dat[0]= m_AMP_DEVICE_ADDR;
	dat[0]= 0x06;
	if (isMute)
		dat[1]= 0x07;
	else
		dat[1]= 0x00;
	AudioAmp_AdoAmp_Tas5711L_write(m_I2C_MASTER,2,dat);
#endif
}

//tlm add 20100919
void AudioAmp_SetMasterVolume(UINT8 iValue)
{
#if defined(ENABLE_AMP_USE_HW_I2C)
	UINT8 dat[2];
	//dat[0]= m_AMP_DEVICE_ADDR;
	dat[0]= 0x07;
	dat[1]= iValue;
	AudioAmp_AdoAmp_Tas5711L_write(m_I2C_MASTER,2,dat);
#endif
}

static int mAudioAmp_GetMappedSubWoofVolume(int index)
{
	//SourceOption source = SetupClass::GetInstance()->GetSource();
	//int *pVolTable = SetupClass::GetInstance()->GetSubWoofVolumeCurveTable(source);
//	int volTableAtv[12] = { 50, 42, 38, 34, 30, 26, 22, 18, 14, 10, 8, 6};
	int volTableAtv[12] = { 50, 42, 38, 34, 30, 26, 22, 16, 10, 7, 3, 1};  //tlm 20111111 32e83

	int *pVolTable = volTableAtv;
	int value = 0;

	if (index == 0)
 		value = 0xff;
	else if (index == 1)
		value = pVolTable[1];
	else {
		int preIdx = 0, nextIdx = 0;
		int tableIdx = 0, preTableIdx = 0;

		if (index > 1 && index <= 10) {
			preIdx = 1;
			nextIdx = 10;
			tableIdx = 2;
			preTableIdx = 1;
		} else if (index > 10 && index <= 20) {
			preIdx = 10;
			nextIdx = 20;
			tableIdx = 3;
			preTableIdx = 2;
		} else if (index > 20 && index <= 30) {
			preIdx = 20;
			nextIdx = 30;
			tableIdx = 4;
			preTableIdx = 3;
		} else if (index > 30 && index <= 40) {
			preIdx = 30;
			nextIdx = 40;
			tableIdx = 5;
			preTableIdx = 4;
		} else if (index > 40 && index <= 50) {
			preIdx = 40;
			nextIdx = 50;
			tableIdx = 6;
			preTableIdx = 5;
		} else if (index > 50 && index <= 60) {
			preIdx = 50;
			nextIdx = 60;
			tableIdx = 7;
			preTableIdx = 6;
		} else if (index > 60 && index <= 70) {
			preIdx = 60;
			nextIdx = 70;
			tableIdx = 8;
			preTableIdx = 7;
		} else if (index > 70 && index <= 80) {
			preIdx = 70;
			nextIdx = 80;
			tableIdx = 9;
			preTableIdx = 8;
		} else if (index > 80 && index <= 90) {
			preIdx = 80;
			nextIdx = 90;
			tableIdx = 10;
			preTableIdx = 9;
		} else if (index > 90 && index <= 100) {
			preIdx = 90;
			nextIdx = 100;
			tableIdx = 11;
			preTableIdx = 10;
		}

		//interpolation
		value = (int)((float)((index - preIdx) * (pVolTable[tableIdx] - pVolTable[preTableIdx])) / (nextIdx - preIdx));
		value += pVolTable[preTableIdx];
		//printf("===vol = %d ===\n", value);
	}

	return value;
}

void AudioAmp_SetSubWoof(BOOL isEnable)
{
#if defined(ENABLE_AMP_USE_HW_I2C)
	UINT8 dat[2];
	dat[0]= 0x0A;

	if (isEnable)
		dat[1]= 0x00;
	else
		dat[1]= 0xFF;

	//printf("%s argv=%d , vol=%d\n", __FUNCTION__, isEnable, dat[1]);
	AudioAmp_AdoAmp_Tas5711L_write(m_I2C_MASTER,2,dat);
#endif
}

